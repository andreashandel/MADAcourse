{
  "hash": "39b2eae17b75029e79dcf9fb1eb1d9d2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Generating synthetic data with R\nsubtitle: \"\"\n---\n\n\n\n\n\n# Overview\nIn this unit, we look at a few examples of generating synthetic data with `R`.\n\n\n# Learning Objectives\n\n* Be able to generate synthetic data with `R` code.\n\n\n# Introduction\n\nWhile there are `R` packages available that help with the generation of synthetic data - and we will discuss them in a different unit, it is also fairly easy to use basic `R` functionality to generate simulated data. We'll do a few examples to show how this can be done.\n\nAI tools are very useful for generating synthetic data. In fact, the code in the examples below was partially generated through back and forth with ChatGPT, together with some manual editing. More on using AI to generate data is provided in another unit of this module, and the more general topic of LLM AI tool use for coding is covered in the [AI module](../../module-ai/ai-overview.qmd).\n\n\n# Example 1\n\nFor the first example, we'll generate a simple dataset of some hypothetical clinical trial for some treatment (say, a Cholesterol lowering medication) and its impact on outcomes such as Cholesterol levels and adverse events.\n\n:::note\nIt is often useful to go slow and type your own code, or copy and paste the code chunks below and execute one at a time. However, if you are in a hurry, you can find the code for this example in [this file](/code/synthetic-data-new-R-example-1-code.R).\n:::\n\n:::note\nIn the code below, you might be wondering what the `dplyr::glimpse()` and similar such notation is about. This notation indicates explicitly from which package the function comes. Once you loaded a package, that's not necessary anymore, just using `glimpse()` would work equally. But it is often nice to quickly see what package a function comes from. An important thing to note is that some packages share function names. In such cases, if a function appears in multiple packages in your environment, `R` will default to using the one from the most recently loaded package. Using explicit notation is a good way to be sure you're using the function you want! Thus, you'll see me use the explicit notation often, though not always. It's typically a matter of being more explicit versus typing less. I switch back and forth.\n:::\n\n\n## Setup\n\nWe'll start by loading the packages used in the code below. While we will not use packages that are specifically meant to generate synthetic data, we will still use several common packages that make data generation tasks easier. That said, you could also do all of this with base `R` and no additional packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make sure the packages are installed\n# Load required packages\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(lubridate)\nlibrary(ggplot2)\nlibrary(here)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set a seed for reproducibility\nset.seed(123)\n# Define the number of observations (patients) to generate\nn_patients <- 100\n```\n:::\n\n\n\n## Generating data \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty data frame with placeholders for variables\nsyn_dat <- data.frame(\n  PatientID = numeric(n_patients),\n  Age = numeric(n_patients),\n  Gender = character(n_patients),\n  TreatmentGroup = character(n_patients),\n  EnrollmentDate = lubridate::as_date(character(n_patients)),\n  BloodPressure = numeric(n_patients),\n  Cholesterol = numeric(n_patients),\n  AdverseEvent = integer(n_patients)\n)\n\n# Variable 1: Patient ID\nsyn_dat$PatientID <- 1:n_patients\n\n# Variable 2: Age (numeric variable)\nsyn_dat$Age <- round(rnorm(n_patients, mean = 45, sd = 10), 1)\n\n# Variable 3: Gender (categorical variable)\nsyn_dat$Gender <- purrr::map_chr(sample(c(\"Male\", \"Female\"), n_patients, replace = TRUE), as.character)\n\n# Variable 4: Treatment Group (categorical variable)\nsyn_dat$TreatmentGroup <- purrr::map_chr(sample(c(\"A\", \"B\", \"Placebo\"), n_patients, replace = TRUE), as.character)\n\n# Variable 5: Date of Enrollment (date variable)\nsyn_dat$EnrollmentDate <- lubridate::as_date(sample(seq(from = lubridate::as_date(\"2022-01-01\"), to = lubridate::as_date(\"2022-12-31\"), by = \"days\"), n_patients, replace = TRUE))\n\n# Variable 6: Blood Pressure (numeric variable)\nsyn_dat$BloodPressure <- round(runif(n_patients, min = 90, max = 160), 1)\n\n# Variable 7: Cholesterol Level (numeric variable)\n# Option 1: Cholesterol is independent of treatment\n#syn_dat$Cholesterol <- round(rnorm(n_patients, mean = 200, sd = 30), 1)\n\n# Option 2: Cholesterol is dependent on treatment\nsyn_dat$Cholesterol[syn_dat$TreatmentGroup == \"A\"] <- round(rnorm(sum(syn_dat$TreatmentGroup == \"A\"), mean = 160, sd = 10), 1)\nsyn_dat$Cholesterol[syn_dat$TreatmentGroup == \"B\"] <- round(rnorm(sum(syn_dat$TreatmentGroup == \"B\"), mean = 180, sd = 10), 1)\nsyn_dat$Cholesterol[syn_dat$TreatmentGroup == \"Placebo\"] <- round(rnorm(sum(syn_dat$TreatmentGroup == \"Placebo\"), mean = 200, sd = 10), 1)\n\n# Variable 8: Adverse Event (binary variable, 0 = No, 1 = Yes)\n# Option 1: Adverse events are independent of treatment\n#syn_dat$AdverseEvent <- purrr::map_int(sample(0:1, n_patients, replace = TRUE, prob = c(0.8, 0.2)), as.integer)\n\n# Option 2: Adverse events are influenced by treatment status\nsyn_dat$AdverseEvent[syn_dat$TreatmentGroup == \"A\"] <- purrr::map_int(sample(0:1, sum(syn_dat$TreatmentGroup == \"A\"), replace = TRUE, prob = c(0.5, 0.5)), as.integer)\nsyn_dat$AdverseEvent[syn_dat$TreatmentGroup == \"B\"] <- purrr::map_int(sample(0:1, sum(syn_dat$TreatmentGroup == \"B\"), replace = TRUE, prob = c(0.7, 0.3)), as.integer)\nsyn_dat$AdverseEvent[syn_dat$TreatmentGroup == \"Placebo\"] <- purrr::map_int(sample(0:1, sum(syn_dat$TreatmentGroup == \"Placebo\"), replace = TRUE, prob = c(0.9, 0.1)), as.integer)\n\n\n# Print the first few rows of the generated data\nhead(syn_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PatientID  Age Gender TreatmentGroup EnrollmentDate BloodPressure Cholesterol\n1         1 39.4 Female              B     2022-08-25         152.0       179.7\n2         2 42.7 Female              B     2022-06-14         128.7       192.2\n3         3 60.6 Female              A     2022-04-17         153.4       150.6\n4         4 45.7   Male              B     2022-02-02         131.1       171.7\n5         5 46.3 Female              A     2022-03-24         119.6       160.5\n6         6 62.2 Female              A     2022-12-20         156.5       154.3\n  AdverseEvent\n1            1\n2            0\n3            0\n4            0\n5            1\n6            1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Save the simulated data to a CSV and Rds file\nwrite.csv(syn_dat, here(\"data\",\"syn_dat.csv\"), row.names = FALSE)\n# if we wanted an RDS version\n#saveRDS(syn_dat, here(\"data\",\"syn_dat.Rds\"))\n```\n:::\n\n\n\n## Checking data \n\nTake a peek at the generated data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(syn_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PatientID           Age           Gender          TreatmentGroup    \n Min.   :  1.00   Min.   :21.90   Length:100         Length:100        \n 1st Qu.: 25.75   1st Qu.:40.08   Class :character   Class :character  \n Median : 50.50   Median :45.60   Mode  :character   Mode  :character  \n Mean   : 50.50   Mean   :45.90                                        \n 3rd Qu.: 75.25   3rd Qu.:51.92                                        \n Max.   :100.00   Max.   :66.90                                        \n EnrollmentDate       BloodPressure    Cholesterol     AdverseEvent \n Min.   :2022-01-08   Min.   : 91.3   Min.   :129.6   Min.   :0.00  \n 1st Qu.:2022-04-06   1st Qu.:110.7   1st Qu.:160.7   1st Qu.:0.00  \n Median :2022-06-25   Median :130.8   Median :176.3   Median :0.00  \n Mean   :2022-06-30   Mean   :128.0   Mean   :175.2   Mean   :0.29  \n 3rd Qu.:2022-10-04   3rd Qu.:147.4   3rd Qu.:188.7   3rd Qu.:1.00  \n Max.   :2022-12-30   Max.   :159.5   Max.   :223.7   Max.   :1.00  \n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::glimpse(syn_dat)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 100\nColumns: 8\n$ PatientID      <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, …\n$ Age            <dbl> 39.4, 42.7, 60.6, 45.7, 46.3, 62.2, 49.6, 32.3, 38.1, 4…\n$ Gender         <chr> \"Female\", \"Female\", \"Female\", \"Male\", \"Female\", \"Female…\n$ TreatmentGroup <chr> \"B\", \"B\", \"A\", \"B\", \"A\", \"A\", \"B\", \"Placebo\", \"A\", \"Pla…\n$ EnrollmentDate <date> 2022-08-25, 2022-06-14, 2022-04-17, 2022-02-02, 2022-0…\n$ BloodPressure  <dbl> 152.0, 128.7, 153.4, 131.1, 119.6, 156.5, 139.6, 118.9,…\n$ Cholesterol    <dbl> 179.7, 192.2, 150.6, 171.7, 160.5, 154.3, 172.8, 189.2,…\n$ AdverseEvent   <int> 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1…\n```\n\n\n:::\n\n```{.r .cell-code}\n# Frequency table for adverse events stratified by treatment\ntable(syn_dat$AdverseEvent,syn_dat$TreatmentGroup)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   \n     A  B Placebo\n  0 28 19      24\n  1 15 11       3\n```\n\n\n:::\n\n```{.r .cell-code}\n# ggplot2 boxplot for cholesterol by treatment group\nggplot(syn_dat, aes(x = TreatmentGroup, y = Cholesterol)) +\n  geom_boxplot() +\n  labs(x = \"Treatment Group\", y = \"Cholesterol Level\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](synthetic-data-new-r_files/figure-html/checkdata-1.png){width=672}\n:::\n:::\n\n\n\nThis concludes our first example. This was a very simple setup, with rectangular data. You often encounter these kind of data in clinical trials. As you generate your data, you can build in any dependencies between variables you want to explore. Then later, when you use the data to test your analysis code, you can see if your analysis code can detect the dependencies you built in. We'll come back to that. \n\nYou could also add further complexities into your synthetic data, for instance you could set some values to be missing, or you could add some outliers. The goal is to generate data that has as the important features of your real dataset to allow you to test your analysis approach on data where you now the truth (since you generated it). If your analysis works on your generated data, there is hope it might also work on the real data (for which of course you don't know the truth). We'll define in a later unit what we mean by \"your analysis works\". But basically, you want to be able to recover the patterns/dependencies you built into your data with your analysis methods.\n\n\n# Example 2\n\nIn this example, we'll generate a dataset that has a more complex structure. We'll generate a dataset that has a longitudinal structure, i.e. repeated measurements over time. We'll also generate a dataset that has a hierarchical structure, i.e. measurements nested within groups.    \n\nWe'll walk slowly through the code chunks, you can find all the code in one file [here](/code/synthetic-data-new-R-example-2-code.R).\n\n\n## Setup\n\nThe usual setup steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make sure the packages are installed\n# Load required packages\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(here)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(123)\n# Number of patients in each treatment group\nnum_patients <- 20\n# Number of days and samples per patient\nnum_days <- 7\nnum_samples_per_day <- 1\n```\n:::\n\n\n\n## Generating data \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Treatment group levels\ntreatment_groups <- c(\"Low Dose\", \"High Dose\")\n\n# Generate patient IDs\npatient_ids <- rep(1:num_patients, each = num_days)\n\n# Generate treatment group assignments for each patient\ntreatment_assignments <- rep(sample(treatment_groups, num_patients, replace = TRUE), \n                             each = num_days)\n\n# Generate day IDs for each patient\nday_ids <- rep(1:num_days, times = num_patients)\n\n# Function to generate drug concentrations with variability\ngenerate_drug_concentrations <- function(day, dose_group, patient_id) {\n  baseline_concentration <- ifelse(dose_group == \"Low Dose\", 8, 15)\n  patient_variation <- rnorm(1, mean = 0, sd = 1)\n  time_variation <- exp(-0.1*day)\n  baseline_concentration * time_variation + patient_variation \n}\n\n\n# Generate drug concentrations for each sample\ndrug_concentrations <- mapply(generate_drug_concentrations, \n                              day = rep(day_ids, each = num_samples_per_day), \n                              dose_group = treatment_assignments,\n                              patient_id = rep(1:num_patients, each = num_days))\n\n\n# Flatten the matrix to a vector\ndrug_concentrations <- as.vector(drug_concentrations)\n\n# Generate cholesterol levels for each sample \n# (assuming a positive correlation with drug concentration)\ncholesterol_levels <- drug_concentrations + \n  rnorm(num_patients * num_days * num_samples_per_day, mean = 0, sd = 5)\n\n# Generate adverse events based on drug concentration \n# (assuming a higher chance of adverse events with higher concentration)\n# Sigmoid function to map concentrations to probabilities\nadverse_events_prob <- plogis(drug_concentrations / 10) \nadverse_events <- rbinom(num_patients * num_days * num_samples_per_day, \n                         size = 1, prob = adverse_events_prob)\n\n# Create a data frame\nsyn_dat2 <- data.frame(\n  PatientID = rep(patient_ids, each = num_samples_per_day),\n  TreatmentGroup = rep(treatment_assignments, each = num_samples_per_day),\n  Day = rep(day_ids, each = num_samples_per_day),\n  DrugConcentration = drug_concentrations,\n  CholesterolLevel = cholesterol_levels,\n  AdverseEvent = adverse_events\n)\n```\n:::\n\n\n\n## Checking data \n\nTake a peek at the generated data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print the first few rows of the generated dataset\nprint(head(syn_dat2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PatientID TreatmentGroup Day DrugConcentration CholesterolLevel AdverseEvent\n1         1       Low Dose   1          8.462781        12.401475            0\n2         1       Low Dose   2          6.909660        10.754871            0\n3         1       Low Dose   3          6.327317         7.988330            0\n4         1       Low Dose   4          5.473243         0.431360            1\n5         1       Low Dose   5          4.296404         3.699141            0\n6         1       Low Dose   6          6.177406         4.775430            1\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(syn_dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   PatientID     TreatmentGroup          Day    DrugConcentration\n Min.   : 1.00   Length:140         Min.   :1   Min.   : 2.081   \n 1st Qu.: 5.75   Class :character   1st Qu.:2   1st Qu.: 5.174   \n Median :10.50   Mode  :character   Median :4   Median : 7.056   \n Mean   :10.50                      Mean   :4   Mean   : 7.593   \n 3rd Qu.:15.25                      3rd Qu.:6   3rd Qu.: 9.738   \n Max.   :20.00                      Max.   :7   Max.   :14.933   \n CholesterolLevel  AdverseEvent   \n Min.   :-4.494   Min.   :0.0000  \n 1st Qu.: 3.844   1st Qu.:0.0000  \n Median : 7.234   Median :1.0000  \n Mean   : 7.855   Mean   :0.6571  \n 3rd Qu.:11.259   3rd Qu.:1.0000  \n Max.   :24.422   Max.   :1.0000  \n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::glimpse(syn_dat2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 140\nColumns: 6\n$ PatientID         <int> 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3…\n$ TreatmentGroup    <chr> \"Low Dose\", \"Low Dose\", \"Low Dose\", \"Low Dose\", \"Low…\n$ Day               <int> 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4…\n$ DrugConcentration <dbl> 8.462781, 6.909660, 6.327317, 5.473243, 4.296404, 6.…\n$ CholesterolLevel  <dbl> 12.4014754, 10.7548711, 7.9883301, 0.4313600, 3.6991…\n$ AdverseEvent      <int> 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1…\n```\n\n\n:::\n:::\n\n\n\n## Exploratory plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot drug concentrations over time for each individual using ggplot2\np1 <- ggplot(syn_dat2, aes(x = Day, y = DrugConcentration, \n                      group = as.factor(PatientID), color = TreatmentGroup)) +\n  geom_line() +\n  labs(title = \"Drug Concentrations Over Time\",\n       x = \"Day\",\n       y = \"Drug Concentration\",\n       color = \"TreatmentGroup\") +\n  theme_minimal()\nplot(p1)\n```\n\n::: {.cell-output-display}\n![](synthetic-data-new-r_files/figure-html/plotdata-ex2-1.png){width=672}\n:::\n\n```{.r .cell-code}\np2 <- ggplot(syn_dat2, aes(x = as.factor(AdverseEvent), y = DrugConcentration, \n                           fill = TreatmentGroup)) +\n  geom_boxplot(width = 0.7, position = position_dodge(width = 0.8), color = \"black\") +\n  geom_point(aes(color = TreatmentGroup), position = position_dodge(width = 0.8), \n             size = 3, shape = 16) +  # Overlay raw data points\n  labs(\n    x = \"Adverse Events\",\n    y = \"Drug Concentration\",\n    title = \"Boxplot of Drug Concentration by Adverse Events and Treatment\"\n  ) +\n  scale_color_manual(values = c(\"A\" = \"blue\", \"B\" = \"red\")) +  # Customize color for each treatment\n  theme_minimal() +\n  theme(legend.position = \"top\")\nplot(p2)\n```\n\n::: {.cell-output-display}\n![](synthetic-data-new-r_files/figure-html/plotdata-ex2-2.png){width=672}\n:::\n:::\n\n\nThis dataset has a bit more complicated structure than the previous one, but it isn't much harder to generate it with code. You'll want to generate your data such that it mimics the real data you plan on analyzing.\n\n## Save data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save the simulated data to a CSV or Rds file\nwrite.csv(syn_dat2, here(\"data\",\"syn_dat2.csv\"), row.names = FALSE)\n# if we wanted an RDS version\n#saveRDS(syn_dat2, here(\"data\",\"syn_dat2.Rds\"))\n```\n:::\n\n\nWe are saving the data as CSV and Rds files. CSV files are readable with pretty much any software and thus very portable. Rds files are `R`-specific, thus not as flexible. The advantage of Rds files is that they are generally smaller, and they retain information about the variables, e.g. if they are factor or numeric variables. Either format works, sometimes one or the other might be better.\n\n\n\n# Summary\n\nIt is fairly easy to generate synthetic data with some basic `R` commands, and it's even easier if you use some LLM AI tool to help you write the code. \n\nSince you generate the data, you can decide what dependencies between variables you want to add, and you can then test your models to see if they can find those patterns. We'll get to that in another unit.\n\n\n# Further Resources\n\nWhile the manual generation of data is generally fairly easy and gives you the most control, sometimes using `R` packages specifically designed for this purpose can be useful. We'll look at a few in a later unit. \n\n\n",
    "supporting": [
      "synthetic-data-new-r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}